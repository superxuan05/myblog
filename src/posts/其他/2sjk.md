---
title: 数据库概览2
cover: /assets/images/cover2.jpg
icon: pen-to-square
date: 2025-12-23
category:
  - 数据库	
star: true
sticky: true
author: superxuan
---

# 2 关系数据模型(关系数据库)
## 2.1 关系数据结构及形式化定义

二维表![[Pasted image 20250420205946.png]]
![[Pasted image 20250420211720.png]]

### 2.1.1 关系的相关概念

关系一般对应规范化的二维表
- 关系的组成：
	- 关系名-->表名
	- 关系模式-->表头
	- 关系实例-->数据

- 域：一组具有相同数据类型的值的集合
- 笛卡儿积：域上的一种集合运算
![[Pasted image 20250420213138.png]]
- 元组：一个元组（Tuple）指二维表中的一行。
- 关系：R（D1，D2 … Dn）
	R为关系名；n为关系度
	关系是笛卡尔积的有限子集。
- 1、码=超键：能够唯一标识一条记录的属性或属性集。
	标识性：一个数据表的所有记录都具有不同的超键
	非空性：不能为空
	有些时候也把码称作“键”

- 2、候选键=候选码：能够唯一标识一条记录的最小属性集
	设关系R(A1，A2，…，An)，其属性为A1，A2，…，An，属性集K为R的子集，K=(Ai，Aj，…，Ak)，1≤i，j，…，k≤n。当且仅当满足下列两个条件时，K被称为**候选码**：
	- 标识性：一个数据表的所有记录都具有不同的候选键
	- 最小性：任一候选键的任何真子集都不能唯一标识一个记录（比如在成绩表中（学号,课程号）是一个候选键，单独的学号，课程号都不能决定一条记录）
	- 非空性：不能为空
	- 候选键是没有多余属性的超键
		举例：学生ID是候选码，那么含有候选码的都是码。

- 3、主键=主码：某个能够唯一标识一条记录的最小属性集（是从候选码里人为挑选的一条）
	唯一性：一个数据表只能有一个主键
	标识性：一个数据表的所有记录都具有不同的主键取值
	非空性：不能为空

- 4.如果关系的R1的属性或属性组K不是R1主码，而是另一关系R2的主码，则称K为关系R1的外码（Foreign Key）.
	并称关系R1为参照关系（Referencing Relation）
	关系R2为被参照关系（Referenced Relation）


- 基数![[Pasted image 20250420213233.png]]

关系可以有三种类型：基本关系（基本表），查询表，视图表
- **基本关系（又称为基本表）**：**实际存在**的表，是实际存储数据的逻辑表示
- **查询表**：**查询结果**对应的表
- **视图表**：由基本表或其他视图表导出的表，**是虚表**，不对应实际存储的数据

基本关系的性质：
（1）列是同质的，每一列来自同一域
（2）不同的列可出自同一域
（3）列的顺序无所谓
（4）任意两个元组的码不能取相同的值
（5）行的顺序无所谓
（6）分量必须取原子值，即每一个分量都必须是不可分的数据项

### 2.1.2 关系模式

- 关系模式（Relation Schema）是型
- 关系是值

关系模式是对关系的描述
- 元组集合的结构
- 元组语义以及完整性约束条件
- 属性间的数据依赖关系集合     

关系模式：关系的描述 R（U，D，DOM，F）
	R是关系名，U为组成该关系的属性名的集合，D为U中属性所来自的域，DOM为属性向域的映像集合，F为属性间数据的依赖关系

### 2.1.3 关系数据库

关系数据库的型也称为关系数据库模式，是对关系数据库的描述
关系数据库的值是这些关系模式在某一时刻对应的关系的集合，通常就称为关系数据库
- 在关系元组中允许出现空值。
- 空值表示信息的空缺。空值表示未知的值或不存在值。


## 2.2 关系操作

- **关系操作的特点是集合操作方式，也即操作的对象和结果都是集合。也称为一次一集合（set-at-a-time）的方式**
- 非关系数据模型的数据操作方式称为**一次一记录**（record-at-a-time）

关系模型常用关系操作如下。
![[Pasted image 20250421210019.png]]
常用操作：查询，插入，删除，修改
查询又包括：选择，投影，连接，除，并，差，交，笛卡儿积

### 2.2.1 关系运算

**1.关系数据语言的分类**
- 关系代数 和 关系演算
- 介于两者之间的结构化查询语言SQL（高度非过程化的语言）
	- **高度非过程化**：使用SQL语句访问数据库时，用户无需告诉计算机如何一步步完成任务，只需描述要做什么，数据库管理系统会自动完成全部工作。
	- **面向集合的操作方式**：SQL语言采用集合操作方式，不仅查询结果是记录的集合，插入、删除和更新操作也是基于记录的集合。
	- **多种使用方式**：SQL既可以作为独立语言直接交互使用，也可以嵌入到如Java、C#等高级程序设计语言中使用
![[Pasted image 20250421210105.png]]
**2.关系代数**

	关系代数是一种抽象的查询语言，它用对关系的运算来表达查询
  - **传统的集合运算**：运算从行的角度进行、
    并（union）
	差（except）
	交（intersection）
	笛卡儿积（cartesian product）
	 条件：①目相同（属性数相同）②相对应的属性来自同一域

  - **专门的关系运算**：运算同时涉及行和列
	  作为关系数据系统 ，最小应具备的关系运算是 选择、投影、连接  
![[Pasted image 20250421211342.png]]

数据库中五种基本运算：差，并，投影，选择，笛卡儿积

一. 传统的的集合运算
(1). 并（union）
 
 并：对于关系R和S，并操作就是将两个关系上下拼在一起形成一个新的关系，记为R∪S
- **数学表示**：$R∪S ={t|t∈R\vee t ∈S}$
- **要求**：关系 R 和 S 必须是类型相兼容的，即具有相同数量和类型的属性。
- **结果**：产生一个包含 R 和 S 中所有唯一元组的新关系。
- **注意**：相同元组在并集中只出现一次；

(2). 差（except）
 
 差：对于关系R和S ，求他们的差，就是在R 中去掉两个关系中所有相同的行，形成一个新的关系，记为R- S
- **数学表示**：$R-S ={t|t∈R\vee t ∉ S}$
- **要求**：关系 R 和 S 必须是类型相兼容的。
- **结果**：产生一个新关系，包含属于 R 但不属于 S 的元组。
 两关系的交集可以通过差运算导出: R∩S= R-(R-S)
![[Pasted image 20250421211505.png]]

(3). 交 (Intersection)
交：对于关系R 和S ，求他们的交，就是选出两个关系中所有相同的行，形成一个新的关系，记为R ∩S
- **数学表示**：$R∩S ={t|t∈R\wedge t∈S}$
- **要求**：关系 R 和 S 必须是类型相兼容的。
- **结果**：产生一个新关系，包含同时属于 R 和 S 的元组。
- **注意**：相同元组在交集中只出现一次;
![[Pasted image 20250421211702.png]]

(4). 笛卡尔积（cartersian product）
笛卡尔积：对于关系R和S，求他们的笛卡尔积，就是两个关系所有元组的不同排列组合，形成一个新的关系，记为R×S 
- **数学表示**：$R×S={t_rt_s|t_r∈R\wedge t_s∈S}$
- **结果**：产生一个新关系，其每个元组由 R 的一个元组和 S 的一个元组组成，元组总数为 R 和 S 元组数的乘积。
![[Pasted image 20250421211735.png]]

**注意事项**

- **并集与交集**：在实际应用中，由于关系数据库中的关系通常定义为无序集合，因此并集和交集操作会自动去除重复的元组。
- **广义笛卡儿积**：这是一个强大的操作，它允许您组合来自两个关系的数据，即使它们之间没有直接的关联。这个操作是许多更复杂操作的基础，例如连接操作。


二、专门的运算关系

 **术语解释**
1. **元组（Tuple）**: 在关系模型中，元组是表中的一行。
2. **属性（Attribute）**: 元组中的一个分量，类似于表中的一列。
3. **属性列/属性组（Attribute List/Group）**: 一个或多个属性构成的集合。
4. **连接（Concatenation）**: 把两个元组拼接在一起，形成一个更长的元组。
5. **象集（Image Set）**: 对于关系 R 中的特定值 x，其象集包含所有在 R 中 X 值为 x 的 Z 值。

示例：R(X, Z) 关系和 X = {S} 为例，我们有： 
- **001 的象集 $Z_{001}$​**: 包含了 S = 001 时，关系 R 中 Z 的所有值。即，所有 R 中 S 值为 001 的元组在 Z 上的值集合。 
- **002 的象集 $Z_{002}$​**: 只包含一个值，因为在 R 中只有一个元组的 S 值为 002。 
- **003 的象集 $Z_{003}$​**: 包含了两个值，对应于 S = 003 的两个不同的 Z 值。

![](https://picx.zhimg.com/v2-a5c05a3cf683593c3493627be2061e65_1440w.jpg)


1.选择 (Selection)

选择运算是关系代数中非常重要的一项运算，它对应于 SQL 中的 `WHERE` 子句。按照指定的条件筛选出满足条件的元组（行）。

- 定义
	- 符号：σ
	- 表达式：$σ_F​(R)$
	- 逻辑：从关系 R 中选择使得逻辑表达式 F 为真的所有元组t。
	![[Pasted image 20250421214529.png]]
- 逻辑表达式 F

	- 表达式 F 可以是任何能够对关系中的元组进行评估的逻辑条件，例如 $A_1​=5、A_2>10$ 或者 $A_3​="John"$。
	- 这些条件可以使用逻辑运算符（AND, OR, NOT）组合起来，以形成更复杂的查询条件。

- 示例
	如果我们有一个学生表 Students(ID,Name,Age,Major)，并且我们想选择所有主修计算机科学的学生，我们可以使用以下选择表达式：$σ_{Major="Computer Science"​}(Students)$
	这将返回一个新的关系，其中包含了所有满足条件 Major="Computer Science" 的元组。

- SQL 对应
	在 SQL 中，同样的操作会用下面的查询来完成：

```sql
SELECT * FROM Students WHERE Major = 'Computer Science';
```

- 注意
	- 选择运算是从关系的水平方向进行的，即它过滤掉不满足条件的行。
	- 选择运算的结果仍然是一个关系，这意味着结果可以作为另一个运算的输入。
	- 选择运算不会改变元组的属性，它只是简单地包含或排除整个元组。


2.投影 (Projection)

投影运算是关系代数中的另一种基本操作，它对应于 SQL 中的 `SELECT` 语句（特定列的选择）。投影用于提取关系中的特定列，并创建一个新的关系，该关系仅包含指定的列。

- 定义
	- 符号：π
	- 表达式：$π_A​(R)$
	- 逻辑：从关系 R 中提取属性子集 A，并创建一个新关系，其中包含原关系的指定列。

- 属性子集 A
	- A 是关系 R 中的属性集合，可以是任意数量的属性。
	- 投影操作将从原始关系中选择这些属性，并在新关系中仅包含这些列。

-  示例
	假设我们有一个学生表 Students(ID,Name,Age,Major)，并且我们只对学生的名字和专业感兴趣，我们可以使用以下投影表达式：$π_{Name, Major}​(Students)$
	这将返回一个新的关系，其中仅包含两列：Name 和 Major。

![[Pasted image 20250421214914.png]]

- 注意投影**要取消重复的CS元组**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/1afcd55a3d06d9abbcae442a95a4361f.png)

- SQL 对应

在 SQL 中，同样的操作会用下面的查询来完成：

```sql
SELECT Name, Major FROM Students;
```

- 注意

- 投影运算是从关系的垂直方向进行的，即它只选择所需的列，而忽略其他列。
- 在执行投影运算时，可能会出现重复的行。在关系模型中，关系被视为一个集合，因此所有的重复行都会被去除，以确保结果中每个元组都是唯一的。
- 当需要对关系进行筛选和属性选择时，通常首先应用选择运算以减少数据集的大小，然后应用投影运算以提取所需的列。

![](https://pic4.zhimg.com/v2-40df9b38a3350945199e955a341cf591_1440w.jpg)

3.连接 (Join)

- 定义

	- **表示法**：$R⋈_{AθB}​S$
	- **逻辑**：从关系 R 和 S 的广义笛卡儿积中选取满足 AθB 条件的元组对。

- 参数
	- A 和 B：分别是关系 R 和 S 上的属性组。
	- θ：比较运算符，例如 $=、≠、<、>$ 等。

- 类型

1. **等值连接 (Equi-Join)**  
- 定义：当 θ 为等于（=）时的连接称为等值连接。
- 表示法：$R⋈_{A=B}​S$
- 特点：只包含在指定属性上具有相等值的元组对。

可以按照如下步骤考虑，最终形成新的关系，记为
- 首先找到关系R RR和S SS中属性相同的列
- 然后找到两列中相同的元素
- 将相同元素所在的行组成新的一行，需要用【关系.属性】的格式区两个关系中相同的属性
![[Pasted image 20250421220808.png]]


2. **自然连接 (Natural Join)**  
- 定义：一种特殊的等值连接，它自动找出两个关系中名称相同的所有属性，并基于这些属性的相等性进行连接。
- 表示法：R⋈S
- 特点：结果中不会有重复的属性列，仅包含那些在两个关系中共有的属性的元组。
![[Pasted image 20250421221151.png]]

 示例

假设有两个关系 R 和 S，其中 R 中有属性 A 和 S 中有属性 B，要在 A 和 B 上进行等值连接，你会写：$R⋈_{A=B}​S$

这将返回一个新的关系，其中包括了 R 和 S 的所有元组对，这些元组对在 A 和 B 上的值相等。

- SQL 对应
	在 SQL 中，等值连接可以使用 `INNER JOIN` 关键字来实现，而自然连接通常需要使用 `JOIN` 关键字加上适当的 `ON` 子句来指定连接条件。


3. **外连接 (Outer Join)**

  悬浮元组的概念：R和S在做自然连接时，R中某些元组有可能在S中不存在公共属性上值相等的元组，就会造成R中这些元组在操作时被舍弃（反过来S也是这样）。例如上图自然连接中就舍弃了R的第4个元组和S的第5个元组

  外连接允许在连接结果中包含即使在一个关系中没有匹配元组也会出现的行。外连接有以下三种类型：

1. **左外连接 (Left Outer Join)**  
    

- 包含左关系（R）的所有元组，如果在右关系（S）中没有匹配，则在右侧填充 `NULL`。
- **右外连接 (Right Outer Join)**  
    
- 包含右关系（S）的所有元组，如果在左关系 包含左关系和右关系的所有元组，无匹配的地方填充 `NULL`。  
    ![[Pasted image 20250421221627.png|450]]

  4. 除运算（Division）
 
 除运算（Division）在关系代数中是一种稍微复杂一点的运算，是笛卡尔积的逆运算，它用于处理如“找到所有...”这类的查询。除运算找到所有在一个关系中的元组，它们与另一个关系中所有元组相关联。

- 定义
	除运算是一种同时考虑行和列的运算。给定两个关系 R(X, Y) 和 S(Y, Z)，其中 X、Y、Z 为属性组，除运算的结果是一个新关系，该关系包含了 R 中那些与 S 中 Y 属性上所有值都有关联的 X 属性上的值。

-  数学表示
	给定 R(X, Y) 和 S(Y, Z)，除运算定义为：$R÷S={t_r​[X]∣t_r​∈R∧π_Y​(S)⊆Y_{tr​[X]}​}$
	
	其中 $Y_{t_r​[X]}$​ 是 R 中 X 值为 $t_r​[X]$ 的象集，即 R 中所有 X 属性值为 $t_r​[X]$ 的元组在 Y 上的值的集合。
![[Pasted image 20250421222250.png]]

- 注意
	- 除运算通常用于处理查询，这些查询需要找到“对于所有...”这类的情况。
	- SQL 没有直接支持除运算，但可以使用组合查询来实现相同的效果。



## 2.3 关系完整性约束

关系完整性规则是对关系的**某种约束条件**，这些约束条件实际上是现实世界的要求，例如性别只能有男、女两种取值

关系模型中有如下三类完整性约束

-   **实体完整性**（entity integrity）
-   **参照完整性**（referential integrity）
-   **用户自定义完整性**（user-defined integrity）

其中实体完整性和参照完整性是关系模型必须满足的完整性约束条件，被称为**关系的两个不变性**

### 2.3.1 实体完整性

**实体完整性：若属性A是基本关系 R 的主属性，则属性A不能取空值**

-   例如“选修（学号,课程号,成绩）”关系中，若（学号,课程号）为主码，则**学号和课程号都不能取空值**

### 2.3.2 参照完整性

 A：参照关系

（注意在关系表示中，**下划线表示主码**）

* * *

【例1】如下两个关系中，**学生关系引用了专业关系的主码“专业号”，也就是说，学生关系中的某个属性的取值需要参照专业关系的属性取值**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/74a421172104aff5c1f2b32e10069959.png)

【例2】如下三个关系中，**选修关系引用了学生关系的主码“学号”和课程关系的主码“课程号”，也就是说，选修关系中某些属性的取值需要参照其他关系的属性取值**

![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/cf35129b182ba9a233f0e7c8089cffcd.png)

【例3】还有，**同一关系内部也可能存在引用关系**。比如在**学生(学号，姓名，性别，专业号，年龄，班长)关系中，“学号”属性是主码，“班长”属性表示该学生所在班级的班长的学号，它引用了本关系“学号”属性，即“班长”必须是确实存在的学生的学号**  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/3f063098470919247ce256cc75214806.png)

 B：外码

外码：设 F 是基本关系 R 的一个或一组属性，但不是关系 R 的码【例如这里 F 是学生关系的专业号】，$K_{s}$​是基本关系 S的主码【例如这里$K_{s}$是专业关系的主码】。若 F 和$K_{s}$相对应，则称 F 是 R的外码(foreign key)【则称专业号是学生关系的外码】，并称基本关系 R 为参照关系(referencing relation)【这里学生关系就是参照关系】，基本关系S为被参照关系(referenced relation)【这里专业关系就是被参照关系】。关系 R 和 S不一定是不同的关系

-   注意：**外码并不一定要与相应的主码同名**，如上面第三个例子中，学生关系的主码为学号，外码为班长。不过，在实际应用中为了便于识别，当外码与相应的主码属于不同关系时，往往给它们取相同的名字。

上面三个例子的参照关系表示如下  
![在这里插入图片描述](https://i-blog.csdnimg.cn/blog_migrate/30dcef3e47d07542eb7cbb7112800485.png)


C：参照完整性规则

**参照完整性：若属性或属性组 F是基本关系 R 的外码，它与基本 S 的主码相对应（关系 R 和 S 不一定是不同的关系），则对于 R中每个元组在 F 上的值必须**

-   **要么取空值（此时 F的每个属性值均为空值）**
-   **要么等于 S 中某个元组的主码值**

* * *

因此对于【例1】，学生关系中每个元组的**专业号**只能取下面两类值

-   **空值**：表示该学生尚未分配专业
-   **非空值（且该值必须是专业关系中某个元组的专业号值）**：表示该学生不能分配到一个不存在的专业中

而对于【例2】，按照道理来说“学号”和“课程号”也可以取两类值，**但是“学号”和“课程号”它作为的是选修关系的主码，所以如果取空值的话将会违背实体完整性规则**

对于【例3】， R 和 S是同一个关系，“班长”可以取两类值

-   **空值**：该班还没有选出班长
-   **非空值**：班长必须是班里的同学

### 2.3.3 用户自定义完整性

用户自定义完整性1针对某一具体关系数据库的约束条件，反映**某一具体应用所涉及的数据必须满足的语义要求**，例如某个属性必须取唯一值，某个非主属性不能取空值等等